#!/usr/bin/env python3

import operator as op
import os
import sys

from argparse import ArgumentParser, RawTextHelpFormatter
from functools import reduce
from itertools import combinations
from random import sample

from util import error, progress, progress_done, usage


USAGE = usage(__file__, """[--min-task MIN_TASK]
                           --max-task MAX_TASK
                           --num-tasks NUM_TASKS
                           NUM_ALLOCATIONS""")

DESC = "Generate random task allocations"


def count_max_allocations(min_tasks, max_tasks, num_tasks):
  unique_tasks = max_tasks - min_tasks + 1

  return reduce(op.mul, range(unique_tasks, unique_tasks - num_tasks, -1), 1)


def generate_all_allocations(min_task, max_task, num_tasks):
    return list(combinations(range(min_task, max_task + 1), num_tasks))


def generate_random_allocations(min_task, max_task, num_tasks, num_allocations):
    tasks = list(range(min_task, max_task + 1))

    task_allocations = set()

    for i in range(num_allocations):
        progress("generating task allocation", i, num_allocations)

        while True:
            task_allocation = tuple(sample(tasks, num_tasks))

            if task_allocation not in task_allocations:
                task_allocations.add(task_allocation)
                break

    progress_done()

    return list(task_allocations)


if __name__ == '__main__':
    def formatter_class(prog):
        return RawTextHelpFormatter(prog, max_help_position=80)

    parser = ArgumentParser(
        usage=USAGE,
        description=DESC,
        formatter_class=formatter_class)

    parser.add_argument('--min-task', type=int, default=1,
        help=str("minimum task id"))

    parser.add_argument('--max-task', required=True, type=int,
        help=str("maximum task id"))

    parser.add_argument('--num-tasks', required=True, type=int,
        help=str("tasks per allocation"))

    parser.add_argument('num_allocations', metavar='NUM_ALLOCATIONS', type=int,
        help=str("number of allocations to generate"))

    ns = parser.parse_args()

    if ns.min_task < 1 or ns.max_task < 1:
        error(__file__, "task ids must be > 0")

    if ns.min_task > ns.max_task:
        error(__file__, "--min-task must be <= --max-task")

    if ns.max_task - ns.min_task + 1 < ns.num_tasks:
        error(__file__, "number of unique tasks smaller than tasks per allocation")

    if ns.num_tasks < 0:
        error(__file__, "--num-tasks must be > 0")

    if ns.num_allocations < 0:
        error(__file__, "NUM_ALLOCATIONS must be > 0")

    max_allocations = count_max_allocations(ns.min_task,
                                            ns.max_task,
                                            ns.num_tasks)

    if ns.num_allocations > max_allocations:
        fmt = "NUM_ALLOCATIONS is too large (must be {} at most)"
        error(__file__, fmt.format(max_allocations))

    if ns.num_allocations == max_allocations:
        task_allocations = generate_all_allocations(ns.min_task,
                                                    ns.max_task,
                                                    ns.num_tasks)
    else:
        task_allocations = generate_random_allocations(ns.min_task,
                                                       ns.max_task,
                                                       ns.num_tasks,
                                                       ns.num_allocations)

    for task_allocation in task_allocations:
        print(' '.join([str(t) for t in task_allocation]))
