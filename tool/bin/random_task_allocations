#!/usr/bin/env python3

import operator as op
import os
import sys

from argparse import ArgumentParser, RawTextHelpFormatter
from functools import reduce
from itertools import combinations, combinations_with_replacement
from random import choices, sample

from util import error, progress, progress_done, usage


USAGE = usage(__file__, """[--min-task MIN_TASK]
                           --max-task MAX_TASK
                           --num-tasks NUM_TASKS
                           [--non-unique]
                           [--processor-sharing]
                           NUM_ALLOCATIONS""")

DESC = "Generate random task allocations"


def count_max_unique_allocations(min_tasks,
                                 max_tasks,
                                 num_tasks,
                                 processor_sharing):

    unique_tasks = max_tasks - min_tasks + 1

    if processor_sharing:
        return unique_tasks**num_tasks
    else:
        return reduce(op.mul, range(unique_tasks, unique_tasks - num_tasks, -1), 1)


def generate_all_unique_allocations(min_task,
                                    max_task,
                                    num_tasks,
                                    processor_sharing):

    c = combinations_with_replacement if processor_sharing else combinations

    return list(c(range(min_task, max_task + 1), num_tasks))


def generate_random_allocations(min_task,
                                max_task,
                                num_tasks,
                                num_allocations,
                                unique,
                                processor_sharing):

    tasks = list(range(min_task, max_task + 1))

    task_allocations = []

    if unique:
      task_allocations_set = set()

    def sample_task_allocation():
        s = choices if processor_sharing else sample

        return tuple(s(tasks, k=num_tasks))

    for i in range(num_allocations):
        progress("generating task allocation", i, num_allocations)

        if unique:
            while True:
                task_allocation = sample_task_allocation()

                if task_allocation not in task_allocations_set:
                    task_allocations_set.add(task_allocation)
                    task_allocations.append(task_allocation)
                    break
        else:
            task_allocations.append(sample_task_allocation())

    progress_done()

    return task_allocations


if __name__ == '__main__':
    def formatter_class(prog):
        return RawTextHelpFormatter(prog, max_help_position=80)

    parser = ArgumentParser(
        usage=USAGE,
        description=DESC,
        formatter_class=formatter_class)

    parser.add_argument('--min-task', type=int, default=1,
        help=str("minimum task id"))

    parser.add_argument('--max-task', required=True, type=int,
        help=str("maximum task id"))

    parser.add_argument('--num-tasks', required=True, type=int,
        help=str("tasks per allocation"))

    parser.add_argument('--non-unique', action='store_true',
        help=str("allow duplicate allocations"))

    parser.add_argument('--processor-sharing', action='store_true',
        help=str("allow multiple tasks to be allocated to the same processor"))

    parser.add_argument('num_allocations', metavar='NUM_ALLOCATIONS', type=int,
        help=str("number of allocations to generate"))

    ns = parser.parse_args()

    if ns.min_task < 1 or ns.max_task < 1:
        error(__file__, "task ids must be > 0")

    if ns.min_task > ns.max_task:
        error(__file__, "--min-task must be <= --max-task")

    if ns.max_task - ns.min_task + 1 < ns.num_tasks:
        error(__file__, "number of unique tasks smaller than tasks per allocation")

    if ns.num_tasks < 0:
        error(__file__, "--num-tasks must be > 0")

    if ns.num_allocations < 0:
        error(__file__, "NUM_ALLOCATIONS must be > 0")

    if not ns.non_unique:
        max_allocations = count_max_unique_allocations(ns.min_task,
                                                       ns.max_task,
                                                       ns.num_tasks,
                                                       ns.processor_sharing)

        if ns.num_allocations > max_allocations:
            fmt = "NUM_ALLOCATIONS is too large (must be {} at most)"
            error(__file__, fmt.format(max_allocations))

    if not ns.non_unique and ns.num_allocations == max_allocations:
       task_allocations = generate_all_unique_allocations(ns.min_task,
                                                          ns.max_task,
                                                          ns.num_tasks,
                                                          ns.processor_sharing)
    else:
        task_allocations = generate_random_allocations(ns.min_task,
                                                       ns.max_task,
                                                       ns.num_tasks,
                                                       ns.num_allocations,
                                                       not ns.non_unique,
                                                       ns.processor_sharing)

    for task_allocation in task_allocations:
        print(' '.join([str(t) for t in task_allocation]))
